## Summary
> 참고할 수 있는 빠른 SQL 쿼리를 쓰기 위한 9가지 모범 사례가 있다.

<br><br>

## 1. 필요한 열만 불러오기
> 필요한 모든 열을 나열하는 작업은 귀찮기 때문에, SQL에서는 습관적으로 SELECT * 를 사용한다.

<br>

#### 하지만, 100개 이상의 열이 있는 테이블의 모든 열을 쿼리하면 어떻게 될까? 🙄🙄
> 당장 시스템 전체에 부담이 될 가능성이 크다.

<br>

사실 이와 같은 대규모 열은 사실 우울할 만큼 자주 마주치게 된다. (그만큼 필요한 열만 불러와야 한다)
> 또한 더 적절한 스키마로 손을 보기가 불가능한 경우가 있다.

<br>

#### 쿼리를 프로토타이핑하는 단계에서는 SELECT *를 사용해도 무방하지만 업무용 환경에서는 실제로 사용되는 열만 요청해야 한다.

<br><br>
  
## 2. 조건부 열 업데이트에는 UPDATE 대신 CASE 사용
> 개발자가 자주 사용하는 UPDATE... WHERE를 사용해 다른 열의 값을 기반으로 한 열의 값을 설정하는 것이다. (코드 예시)
```SQL
UPDATE Users SET Users.Status="Legacy" WHERE Users.ID < 1000
```

<br>

#### 이 방법은 간단하고, 직관적이지만, 경우에 따라 불필요한 문제가 발생할 수 있다.

* 테이블에 데이터를 삽입한 다음 위와 같이 UPDATE를 사용해 이 값을 변경하면 2개의 개별적인 트랜잭션이 된다.
* 행이 수백만 개 있는 경우 부가적인 트랜잭션은 많은 불필요한 작업을 유발한다.

<br>

#### 결론: 대규모 작업에서 더 좋은 방법은 쿼리에 인라인 CASE 문을 사용해 삽입 작업 자체가 이뤄지는 동안 열 값을 설정하는 것이다.

<br><br>

## 3. 큰 테이블 쿼리는 최소한으로 유지
> 테이블에 대한 쿼리는 테이블의 크기와 상관없이 공짜가 아니다.

<br>

* 행 수가 수억 또는 수십억 개에 이르는 테이블에 대한 쿼리라면 더욱 그렇다.
* 할 수 있다면 큰 테이블에 대한 쿼리는 가능한 한 최소한의 개별 작업으로 통합해야 한다.

<br>

#### 결론: 테이블에서 먼저한 열로 쿼리한 후 다른 열로 쿼리하는 경우 하나의 쿼리로 병합하고, 쿼리하는 열에 커버링 인덱스가 있는 지 확인

<br><br>

## 4. 데이터 사전 준비(pre-stage)
> 한 사람 혹은 여러 사용자가 여러 개의 큰 테이블을 조인해 많은 데이터를 집계해야 하는 보고서 또는 저장 프로시저를 주기적으로 실행

<br>

#### 매번 조인을 다시 실행하는 대신 이를 용도에 맞게 테이블에 "사전 준비"하면 모든 사람의 수고를 상당부분 덜 수 있다.

<br>

#### 결론: 이 테이블을 대상으로 보고서 또는 프로시저를 실행할 수 있으므로 공통적인 작업을 한 번만 수행하면 되기 때문이다.

<br><br>

## 5. 삭제와 업데이트는 일괄로 수행
> 행이 수십억 개인 테이블이 있는데 여기서 수백만 개의 행을 제거해야 한다고 가정하자.

<br>

#### 단순한 방법은 그냥 트랜잭션에서 DELETE를 실행하는 것이다. (트랜잭션이 완료될 때까지 전체 테이블 LOCK)

<br>

#### 결론: 세련된 방법은 삭제 또는 업데이트 작업을 다른 항목과 인터리빙할 수 있는 일괄 작업으로 수행한다.

<br><br>

## 6. 임시 테이블을 사용해 커서 성능 개선
> 대부분의 경우는 커서를 피해야 한다.

<br>

#### 커서는 속도가 느리고, 다른 작업을 차단하기 때문이다.

<br>

#### 어떤 이유로든 커서를 사용할 수 밖에 없다면, 임시 테이블로 성능 문제를 완화할 수 있다.

<br><br>

## 7. 스칼라 함수보다는 테이블-값 함수 사용
> 스칼라 함수는 계산을 저장 프로시저와 유사한 SQL 조각으로 캡슐화한다.

<br>

#### SELECT 쿼리에서 스칼라 함수의 결과를 열로 반환하기 위해 일반적으로 사용하는 방법이다.
* 마이크로소프트 SQL 서버에서 이 작업을 많이 했다면, 이제는 테이블-값 함수를 사용하고 쿼리에서 CROSS APPLY를 사용하자!

<br><br>

## 8. 파티셔닝을 이용하여 큰 데이터 이동 방지
> SQL 서버 엔터프라이즈는 “파티셔닝” 기능을 제공하며, 데이터베이스 테이블을 여러 파티션으로 나눌 수 있다. <br>
> 한 테이블을 다른 테이블로 아카이빙한다면 INSERT/DELETE를 사용해 데이터를 옮기지 않고 대신 SWITCH를 사용한다.

## 9. 성능을 위해서는 저장 프로시저 사용, 편리함을 위해서는 ORM 사용
> SQL 코드를 생성하는 소프트웨어 툴킷, 애플리케이션의 프로그래밍 언어와 해당 메타포를 사용해 쿼리를 개발하고 유지하는 데 유용하다.

